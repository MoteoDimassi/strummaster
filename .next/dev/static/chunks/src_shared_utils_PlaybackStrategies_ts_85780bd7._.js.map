{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/shared/utils/PlaybackStrategies.ts"],"sourcesContent":["import { StrumDirection, StrumType } from '../../domain/entities';\nimport { AudioSample } from './AudioSampleFactory';\n\nexport interface PlaybackStrategy {\n  play(\n    samples: AudioSample[],\n    direction: StrumDirection,\n    type: StrumType,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    time?: number,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void>;\n}\n\nexport class BasicStrumStrategy implements PlaybackStrategy {\n  private readonly staggerTime = 0.025; // 25ms delay between strings\n\n  async play(\n    samples: AudioSample[],\n    direction: StrumDirection,\n    type: StrumType,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    time?: number,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (type === 'ghost') return;\n\n    const startTime = time || audioContext.currentTime;\n\n    // Order samples based on strum direction\n    const orderedSamples = direction === 'down'\n      ? samples\n      : [...samples].reverse();\n\n    const playPromises = orderedSamples.map((sample, index) =>\n      this.playSample(sample, startTime + (index * this.staggerTime), audioContext, destination, sourceCallback)\n    );\n\n    await Promise.all(playPromises);\n  }\n\n  private async playSample(\n    sample: AudioSample,\n    time: number,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (!sample.buffer) {\n      throw new Error(`Sample ${sample.id} not loaded`);\n    }\n\n    const source = audioContext.createBufferSource();\n    source.buffer = sample.buffer;\n\n    const gain = audioContext.createGain();\n    gain.gain.value = 1.0;\n\n    source.connect(gain);\n    gain.connect(destination);\n\n    // Регистрируем источник, если предоставлен колбэк\n    if (sourceCallback) {\n      sourceCallback(source);\n    }\n\n    source.start(time);\n  }\n}\n\nexport class AggressiveStrumStrategy implements PlaybackStrategy {\n  private readonly staggerTime = 0.015; // Faster stagger for aggressive sound\n  private readonly gainMultiplier = 1.2;\n\n  async play(\n    samples: AudioSample[],\n    direction: StrumDirection,\n    type: StrumType,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    time?: number,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (type === 'ghost') return;\n\n    const startTime = time || audioContext.currentTime;\n    const orderedSamples = direction === 'down'\n      ? samples\n      : [...samples].reverse();\n\n    const playPromises = orderedSamples.map((sample, index) =>\n      this.playSample(\n        sample,\n        startTime + (index * this.staggerTime),\n        audioContext,\n        destination,\n        this.gainMultiplier,\n        sourceCallback\n      )\n    );\n\n    await Promise.all(playPromises);\n  }\n\n  private async playSample(\n    sample: AudioSample,\n    time: number,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    gainMultiplier: number = 1.0,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (!sample.buffer) {\n      throw new Error(`Sample ${sample.id} not loaded`);\n    }\n\n    const source = audioContext.createBufferSource();\n    source.buffer = sample.buffer;\n\n    const gain = audioContext.createGain();\n    gain.gain.value = gainMultiplier;\n\n    source.connect(gain);\n    gain.connect(destination);\n\n    // Регистрируем источник, если предоставлен колбэк\n    if (sourceCallback) {\n      sourceCallback(source);\n    }\n\n    source.start(time);\n  }\n}\n\nexport class GentleStrumStrategy implements PlaybackStrategy {\n  private readonly staggerTime = 0.035; // Slower stagger for gentle sound\n  private readonly gainMultiplier = 0.8;\n\n  async play(\n    samples: AudioSample[],\n    direction: StrumDirection,\n    type: StrumType,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    time?: number,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (type === 'ghost') return;\n\n    const startTime = time || audioContext.currentTime;\n    const orderedSamples = direction === 'down'\n      ? samples\n      : [...samples].reverse();\n\n    const playPromises = orderedSamples.map((sample, index) =>\n      this.playSample(\n        sample,\n        startTime + (index * this.staggerTime),\n        audioContext,\n        destination,\n        this.gainMultiplier,\n        sourceCallback\n      )\n    );\n\n    await Promise.all(playPromises);\n  }\n\n  private async playSample(\n    sample: AudioSample,\n    time: number,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    gainMultiplier: number = 1.0,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (!sample.buffer) {\n      throw new Error(`Sample ${sample.id} not loaded`);\n    }\n\n    const source = audioContext.createBufferSource();\n    source.buffer = sample.buffer;\n\n    const gain = audioContext.createGain();\n    gain.gain.value = gainMultiplier;\n\n    source.connect(gain);\n    gain.connect(destination);\n\n    // Регистрируем источник, если предоставлен колбэк\n    if (sourceCallback) {\n      sourceCallback(source);\n    }\n\n    source.start(time);\n  }\n}\n\nexport class MuteStrategy implements PlaybackStrategy {\n  async play(\n    samples: AudioSample[],\n    direction: StrumDirection,\n    type: StrumType,\n    audioContext: AudioContext,\n    destination: AudioNode,\n    time?: number,\n    sourceCallback?: (source: AudioBufferSourceNode) => void\n  ): Promise<void> {\n    if (type !== 'mute') return;\n\n    const startTime = time || audioContext.currentTime;\n    \n    // Find mute sample (should be first in array for mute type)\n    const muteSample = samples.find(s => s.id.includes('mute'));\n    if (!muteSample || !muteSample.buffer) {\n      throw new Error('Mute sample not loaded');\n    }\n\n    const source = audioContext.createBufferSource();\n    source.buffer = muteSample.buffer;\n\n    const gain = audioContext.createGain();\n    gain.gain.value = 0.8;\n\n    source.connect(gain);\n    gain.connect(destination);\n\n    // Регистрируем источник, если предоставлен колбэк\n    if (sourceCallback) {\n      sourceCallback(source);\n    }\n\n    source.start(startTime);\n  }\n}\n\nexport type PlaybackStrategyType = 'basic' | 'aggressive' | 'gentle';\n\nexport class PlaybackStrategyFactory {\n  private static strategies: Map<PlaybackStrategyType, PlaybackStrategy> = new Map();\n\n  static {\n    PlaybackStrategyFactory.strategies.set('basic', new BasicStrumStrategy());\n    PlaybackStrategyFactory.strategies.set('aggressive', new AggressiveStrumStrategy());\n    PlaybackStrategyFactory.strategies.set('gentle', new GentleStrumStrategy());\n  }\n\n  static getStrategy(type: PlaybackStrategyType): PlaybackStrategy {\n    const strategy = this.strategies.get(type);\n    if (!strategy) {\n      throw new Error(`Unknown playback strategy: ${type}`);\n    }\n    return strategy;\n  }\n\n  static getMuteStrategy(): PlaybackStrategy {\n    return new MuteStrategy();\n  }\n}"],"names":[],"mappings":"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"}}]
}