{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/store/hooks.ts"],"sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './index';\n\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;"],"names":[],"mappings":";;;;;;AAAA;;AAGO,MAAM,iBAAiB,IAAM,IAAA,wKAAW;AACxC,MAAM,iBAAkD,wKAAW"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/core/tuner/TunerCore.ts"],"sourcesContent":["import { TunerResult } from '../../domain/entities';\n\n// Интерфейсы для адаптеров взаимодействия с Web Audio API\nexport interface AudioDataAdapter {\n  getFloatTimeDomainData(buffer: Float32Array): void;\n  getSampleRate(): number;\n}\n\nexport interface AnimationAdapter {\n  requestAnimationFrame(callback: () => void): number;\n  cancelAnimationFrame(id: number): void;\n}\n\n// Интерфейс для нот гитарного строя\nexport interface GuitarNote {\n  note: string;\n  octave: number;\n  freq: number;\n}\n\nexport class TunerCore {\n  private readonly guitarNotes: GuitarNote[] = [\n    { note: \"E\", octave: 2, freq: 82.41 },\n    { note: \"A\", octave: 2, freq: 110.00 },\n    { note: \"D\", octave: 3, freq: 146.83 },\n    { note: \"G\", octave: 3, freq: 196.00 },\n    { note: \"B\", octave: 3, freq: 246.94 },\n    { note: \"E\", octave: 4, freq: 329.63 }\n  ];\n\n  private readonly noteStrings = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n  /**\n   * Анализирует частоту и возвращает результат тюнера\n   * @param frequency - частота в Гц\n   * @returns результат анализа частоты\n   */\n  analyzeFrequency(frequency: number): TunerResult {\n    const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));\n    const note = Math.round(noteNum) + 69;\n    const noteName = this.noteStrings[note % 12];\n    const cents = Math.floor(1200 * Math.log(frequency / this.frequencyFromNoteNumber(note)) / Math.log(2));\n    const isInTune = Math.abs(cents) < 5;\n\n    return {\n      note: noteName,\n      frequency: Math.round(frequency),\n      cents,\n      isInTune\n    };\n  }\n\n  /**\n   * Анализирует частоту для гитарного строя\n   * @param frequency - частота в Гц\n   * @returns результат анализа частоты для гитары\n   */\n  analyzeFrequencyForGuitar(frequency: number): TunerResult {\n    const closestGuitarNote = this.getClosestGuitarNote(frequency);\n    const cents = Math.floor(1200 * Math.log(frequency / closestGuitarNote.freq) / Math.log(2));\n    const isInTune = Math.abs(cents) < 5;\n\n    return {\n      note: closestGuitarNote.note,\n      frequency: Math.round(frequency),\n      cents,\n      isInTune\n    };\n  }\n\n  /**\n   * Находит ближайшую ноту гитарного строя к заданной частоте\n   * @param pitch - частота в Гц\n   * @returns ближайшая нота гитарного строя\n   */\n  getClosestGuitarNote(pitch: number): GuitarNote {\n    let minDiff = Infinity;\n    let closestNote = this.guitarNotes[0];\n\n    this.guitarNotes.forEach(gNote => {\n      const diff = Math.abs(pitch - gNote.freq);\n      if (diff < minDiff) {\n        minDiff = diff;\n        closestNote = gNote;\n      }\n    });\n\n    return closestNote;\n  }\n\n  /**\n   * Получает все ноты гитарного строя\n   * @returns массив нот гитарного строя\n   */\n  getGuitarNotes(): GuitarNote[] {\n    return [...this.guitarNotes];\n  }\n\n  /**\n   * Преобразует номер ноты в частоту\n   * @param note - номер ноты\n   * @returns частота в Гц\n   */\n  frequencyFromNoteNumber(note: number): number {\n    return 440 * Math.pow(2, (note - 69) / 12);\n  }\n\n  /**\n   * Алгоритм автокорреляции для определения основной частоты\n   * @param buf - буфер с аудио данными\n   * @param sampleRate - частота дискретизации\n   * @returns основная частота в Гц или -1, если частота не определена\n   */\n  autoCorrelate(buf: Float32Array, sampleRate: number): number {\n    // ACF2+ algorithm implementation\n    let SIZE = buf.length;\n    let rms = 0;\n\n    for (let i = 0; i < SIZE; i++) {\n      const val = buf[i];\n      rms += val * val;\n    }\n    rms = Math.sqrt(rms / SIZE);\n\n    if (rms < 0.01) // not enough signal\n      return -1;\n\n    let r1 = 0, r2 = SIZE - 1, thres = 0.2;\n    for (let i = 0; i < SIZE / 2; i++)\n      if (Math.abs(buf[i]) < thres) { r1 = i; break; }\n    for (let i = 1; i < SIZE / 2; i++)\n      if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }\n\n    buf = buf.slice(r1, r2);\n    SIZE = buf.length;\n\n    let c = new Array(SIZE).fill(0);\n    for (let i = 0; i < SIZE; i++)\n      for (let j = 0; j < SIZE - i; j++)\n        c[i] = c[i] + buf[j] * buf[j + i];\n\n    let d = 0; while (c[d] > c[d + 1]) d++;\n    let maxval = -1, maxpos = -1;\n    for (let i = d; i < SIZE; i++) {\n      if (c[i] > maxval) {\n        maxval = c[i];\n        maxpos = i;\n      }\n    }\n    let T0 = maxpos;\n\n    let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];\n    let a = (x1 + x3 - 2 * x2) / 2;\n    let b = (x3 - x1) / 2;\n    if (a) T0 = T0 - b / (2 * a);\n\n    return sampleRate / T0;\n  }\n\n  /**\n   * Анализирует аудио данные с использованием адаптера\n   * @param audioAdapter - адаптер для получения аудио данных\n   * @param buffer - буфер для хранения аудио данных\n   * @returns результат анализа или null, если частота не определена\n   */\n  analyzeAudioData(audioAdapter: AudioDataAdapter, buffer: Float32Array): TunerResult | null {\n    audioAdapter.getFloatTimeDomainData(buffer);\n    const frequency = this.autoCorrelate(buffer, audioAdapter.getSampleRate());\n\n    if (frequency !== -1) {\n      return this.analyzeFrequency(frequency);\n    }\n\n    return null;\n  }\n\n  /**\n   * Запускает непрерывный анализ с использованием адаптеров\n   * @param audioAdapter - адаптер для получения аудио данных\n   * @param animationAdapter - адаптер для анимации\n   * @param buffer - буфер для хранения аудио данных\n   * @param callback - функция обратного вызова для передачи результатов\n   * @param isRunning - функция для проверки состояния работы\n   */\n  startContinuousAnalysis(\n    audioAdapter: AudioDataAdapter,\n    animationAdapter: AnimationAdapter,\n    buffer: Float32Array,\n    callback: (result: TunerResult | null) => void,\n    isRunning: () => boolean\n  ): () => void {\n    let rafID: number | null = null;\n\n    const analyze = () => {\n      if (!isRunning()) {\n        callback(null);\n        return;\n      }\n\n      const result = this.analyzeAudioData(audioAdapter, buffer);\n      callback(result);\n\n      if (isRunning()) {\n        rafID = animationAdapter.requestAnimationFrame(analyze);\n      }\n    };\n\n    analyze();\n\n    // Возвращаем функцию для остановки анализа\n    return () => {\n      if (rafID !== null) {\n        animationAdapter.cancelAnimationFrame(rafID);\n      }\n    };\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/core/adapters/BrowserApiAdapter.ts"],"sourcesContent":["/**\n * Адаптеры для инкапсуляции браузерных API\n * Это позволяет улучшить тестируемость кода и изолировать зависимости от браузера\n */\n\n// Интерфейс для работы с таймерами\nexport interface TimerApiAdapter {\n  setTimeout(callback: () => void, delay: number): number | null;\n  clearTimeout(timerId: number | null): void;\n}\n\n// Интерфейс для работы с анимацией\nexport interface AnimationApiAdapter {\n  requestAnimationFrame(callback: () => void): number;\n  cancelAnimationFrame(id: number): void;\n}\n\n// Интерфейс для работы с аудио\nexport interface AudioApiAdapter {\n  createAudioContext(): AudioContext;\n  createAnalyser(context: AudioContext): AnalyserNode;\n  getUserMedia(constraints?: MediaStreamConstraints): Promise<MediaStream>;\n  createMediaStreamSource(context: AudioContext, stream: MediaStream): MediaStreamAudioSourceNode;\n}\n\n// Реализация адаптера для таймеров на основе браузерного API\nexport class WebTimerApiAdapter implements TimerApiAdapter {\n  setTimeout(callback: () => void, delay: number): number | null {\n    return window.setTimeout(callback, delay);\n  }\n\n  clearTimeout(timerId: number | null): void {\n    if (timerId !== null) {\n      window.clearTimeout(timerId);\n    }\n  }\n}\n\n// Реализация адаптера для анимации на основе браузерного API\nexport class WebAnimationApiAdapter implements AnimationApiAdapter {\n  requestAnimationFrame(callback: () => void): number {\n    return window.requestAnimationFrame(callback);\n  }\n\n  cancelAnimationFrame(id: number): void {\n    window.cancelAnimationFrame(id);\n  }\n}\n\n// Реализация адаптера для аудио на основе браузерного API\nexport class WebAudioApiAdapter implements AudioApiAdapter {\n  createAudioContext(): AudioContext {\n    console.log('[WebAudioApiAdapter] Создание AudioContext');\n    return new AudioContext();\n  }\n\n  createAnalyser(context: AudioContext): AnalyserNode {\n    console.log('[WebAudioApiAdapter] Создание AnalyserNode');\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 2048;\n    analyser.smoothingTimeConstant = 0.8;\n    return analyser;\n  }\n\n  async getUserMedia(constraints?: MediaStreamConstraints): Promise<MediaStream> {\n    console.log('[WebAudioApiAdapter] Запрос доступа к микрофону');\n    const defaultConstraints: MediaStreamConstraints = constraints || {\n      audio: {\n        echoCancellation: false,\n        autoGainControl: false\n      }\n    };\n    \n    try {\n      const stream = await navigator.mediaDevices.getUserMedia(defaultConstraints);\n      console.log('[WebAudioApiAdapter] Доступ к микрофону получен');\n      return stream;\n    } catch (error) {\n      console.error('[WebAudioApiAdapter] Ошибка доступа к микрофону:', error);\n      throw error;\n    }\n  }\n\n  createMediaStreamSource(context: AudioContext, stream: MediaStream): MediaStreamAudioSourceNode {\n    console.log('[WebAudioApiAdapter] Создание MediaStreamAudioSourceNode');\n    return context.createMediaStreamSource(stream);\n  }\n}\n\n// Фабрика для создания адаптеров по умолчанию\nexport class BrowserApiAdapterFactory {\n  static createTimerAdapter(): TimerApiAdapter {\n    return new WebTimerApiAdapter();\n  }\n\n  static createAnimationAdapter(): AnimationApiAdapter {\n    return new WebAnimationApiAdapter();\n  }\n\n  static createAudioAdapter(): AudioApiAdapter {\n    return new WebAudioApiAdapter();\n  }\n}"],"names":[],"mappings":"AAAA;;;CAGC,GAED,mCAAmC;;;;;;;;;;;AAqB5B,MAAM;IACX,WAAW,QAAoB,EAAE,KAAa,EAAiB;QAC7D,OAAO,OAAO,UAAU,CAAC,UAAU;IACrC;IAEA,aAAa,OAAsB,EAAQ;QACzC,IAAI,YAAY,MAAM;YACpB,OAAO,YAAY,CAAC;QACtB;IACF;AACF;AAGO,MAAM;IACX,sBAAsB,QAAoB,EAAU;QAClD,OAAO,OAAO,qBAAqB,CAAC;IACtC;IAEA,qBAAqB,EAAU,EAAQ;QACrC,OAAO,oBAAoB,CAAC;IAC9B;AACF;AAGO,MAAM;IACX,qBAAmC;QACjC,QAAQ,GAAG,CAAC;QACZ,OAAO,IAAI;IACb;IAEA,eAAe,OAAqB,EAAgB;QAClD,QAAQ,GAAG,CAAC;QACZ,MAAM,WAAW,QAAQ,cAAc;QACvC,SAAS,OAAO,GAAG;QACnB,SAAS,qBAAqB,GAAG;QACjC,OAAO;IACT;IAEA,MAAM,aAAa,WAAoC,EAAwB;QAC7E,QAAQ,GAAG,CAAC;QACZ,MAAM,qBAA6C,eAAe;YAChE,OAAO;gBACL,kBAAkB;gBAClB,iBAAiB;YACnB;QACF;QAEA,IAAI;YACF,MAAM,SAAS,MAAM,UAAU,YAAY,CAAC,YAAY,CAAC;YACzD,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oDAAoD;YAClE,MAAM;QACR;IACF;IAEA,wBAAwB,OAAqB,EAAE,MAAmB,EAA8B;QAC9F,QAAQ,GAAG,CAAC;QACZ,OAAO,QAAQ,uBAAuB,CAAC;IACzC;AACF;AAGO,MAAM;IACX,OAAO,qBAAsC;QAC3C,OAAO,IAAI;IACb;IAEA,OAAO,yBAA8C;QACnD,OAAO,IAAI;IACb;IAEA,OAAO,qBAAsC;QAC3C,OAAO,IAAI;IACb;AACF"}},
    {"offset": {"line": 303, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/core/adapters/TunerAdapter.ts"],"sourcesContent":["import {\n  AudioDataAdapter,\n  AnimationAdapter,\n  TunerCore\n} from '../tuner/TunerCore';\nimport { TunerResult } from '../../domain/entities';\nimport { AnimationApiAdapter, AudioApiAdapter, BrowserApiAdapterFactory } from './BrowserApiAdapter';\n\n// Адаптер для AudioData (AnalyserNode)\nclass WebAudioDataAdapter implements AudioDataAdapter {\n  private analyser: AnalyserNode | null = null;\n  private audioContext: AudioContext | null = null;\n  private audioApiAdapter: AudioApiAdapter;\n  private stream: MediaStream | null = null;\n\n  constructor(audioApiAdapter?: AudioApiAdapter) {\n    this.audioApiAdapter = audioApiAdapter || BrowserApiAdapterFactory.createAudioAdapter();\n  }\n\n  // Метод для установки анализатора из TunerService\n  setAnalyser(analyser: AnalyserNode, audioContext: AudioContext): void {\n    this.analyser = analyser;\n    this.audioContext = audioContext;\n  }\n\n  // Метод для создания анализатора, если он не был установлен извне\n  ensureAnalyser(): void {\n    if (!this.analyser || !this.audioContext) {\n      console.log('[WebAudioDataAdapter] Создание AudioContext и AnalyserNode');\n      this.audioContext = this.audioApiAdapter.createAudioContext();\n      this.analyser = this.audioApiAdapter.createAnalyser(this.audioContext);\n      console.log('[WebAudioDataAdapter] ВНИМАНИЕ: AnalyserNode создан, но не подключен к источнику аудио!');\n    }\n  }\n\n  getFloatTimeDomainData(buffer: Float32Array): void {\n    if (this.analyser) {\n      // Проверяем, подключен ли анализатор к какому-либо источнику\n      const hasData = this.checkForAudioData();\n      if (!hasData) {\n        console.warn('[WebAudioDataAdapter] ОШИБКА: AnalyserNode не подключен к источнику аудио!');\n      }\n      this.analyser.getFloatTimeDomainData(buffer as any);\n    }\n  }\n\n  // Вспомогательный метод для проверки наличия аудиоданных\n  private checkForAudioData(): boolean {\n    if (!this.analyser) return false;\n    \n    // Проверяем, есть ли какие-либо данные в анализаторе\n    const tempBuffer = new Float32Array(128);\n    this.analyser.getFloatTimeDomainData(tempBuffer);\n    \n    // Проверяем, есть ли ненулевые значения\n    let hasSignal = false;\n    for (let i = 0; i < tempBuffer.length; i++) {\n      if (tempBuffer[i] !== 0) {\n        hasSignal = true;\n        break;\n      }\n    }\n    \n    return hasSignal;\n  }\n\n  getSampleRate(): number {\n    return this.audioContext?.sampleRate || 44100;\n  }\n\n  async connectMicrophone(): Promise<void> {\n    this.ensureAnalyser();\n    if (!this.audioContext || !this.analyser) {\n      throw new Error('AudioContext or Analyser not initialized');\n    }\n\n    try {\n      this.stream = await this.audioApiAdapter.getUserMedia();\n      const source = this.audioApiAdapter.createMediaStreamSource(this.audioContext, this.stream);\n      source.connect(this.analyser);\n      \n      if (this.audioContext.state === 'suspended') {\n        await this.audioContext.resume();\n      }\n      console.log('[WebAudioDataAdapter] Микрофон успешно подключен');\n    } catch (error) {\n      console.error('[WebAudioDataAdapter] Ошибка подключения микрофона:', error);\n      throw error;\n    }\n  }\n\n  disconnectMicrophone(): void {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n      console.log('[WebAudioDataAdapter] Микрофон отключен');\n    }\n  }\n}\n\n// Адаптер для Animation на основе AnimationApiAdapter\nclass WebAnimationAdapter implements AnimationAdapter {\n  constructor(private animationApiAdapter: AnimationApiAdapter) {}\n\n  requestAnimationFrame(callback: () => void): number {\n    return this.animationApiAdapter.requestAnimationFrame(callback);\n  }\n\n  cancelAnimationFrame(id: number): void {\n    this.animationApiAdapter.cancelAnimationFrame(id);\n  }\n}\n\n/**\n * Адаптер для TunerService, который реализует интерфейсы TunerCore\n * и позволяет существующему коду работать с новой архитектурой\n */\nexport class TunerAdapter {\n  private tunerCore: TunerCore;\n  private audioDataAdapter: WebAudioDataAdapter;\n  private animationAdapter: WebAnimationAdapter;\n  private buffer: Float32Array;\n  private stopContinuousAnalysis: (() => void) | null = null;\n  private isRunning: boolean = false;\n\n  constructor(\n    animationApiAdapter?: AnimationApiAdapter,\n    audioApiAdapter?: AudioApiAdapter\n  ) {\n    this.tunerCore = new TunerCore();\n    this.audioDataAdapter = new WebAudioDataAdapter(audioApiAdapter);\n    this.animationAdapter = new WebAnimationAdapter(\n      animationApiAdapter || BrowserApiAdapterFactory.createAnimationAdapter()\n    );\n    this.buffer = new Float32Array(2048);\n  }\n\n  // Инициализация адаптера\n  async initialize(): Promise<void> {\n    console.log('[TunerAdapter] Инициализация адаптера тюнера');\n    // Убеждаемся, что у нас есть анализатор\n    this.audioDataAdapter.ensureAnalyser();\n    console.log('[TunerAdapter] Анализатор создан, но нет подключения к микрофону');\n  }\n\n  // Делегируем вызовы к TunerCore\n  analyzeFrequency(frequency: number): TunerResult {\n    return this.tunerCore.analyzeFrequency(frequency);\n  }\n\n  analyzeFrequencyForGuitar(frequency: number): TunerResult {\n    return this.tunerCore.analyzeFrequencyForGuitar(frequency);\n  }\n\n  getClosestGuitarNote(pitch: number) {\n    return this.tunerCore.getClosestGuitarNote(pitch);\n  }\n\n  getGuitarNotes() {\n    return this.tunerCore.getGuitarNotes();\n  }\n\n  frequencyFromNoteNumber(note: number): number {\n    return this.tunerCore.frequencyFromNoteNumber(note);\n  }\n\n  autoCorrelate(buf: Float32Array, sampleRate: number): number {\n    return this.tunerCore.autoCorrelate(buf, sampleRate);\n  }\n\n  // Методы для работы с адаптером\n  async start(): Promise<void> {\n    console.log('[TunerAdapter] Запуск тюнера');\n    this.isRunning = true;\n    await this.initialize();\n    await this.audioDataAdapter.connectMicrophone();\n  }\n\n  stop(): void {\n    console.log('[TunerAdapter] Остановка тюнера');\n    this.isRunning = false;\n    // Останавливаем непрерывный анализ, если он запущен\n    if (this.stopContinuousAnalysis) {\n      this.stopContinuousAnalysis();\n      this.stopContinuousAnalysis = null;\n    }\n    this.audioDataAdapter.disconnectMicrophone();\n  }\n\n  async getPitch(): Promise<TunerResult | null> {\n    // Возвращаем null, так как анализ должен выполняться через непрерывный анализ\n    return null;\n  }\n\n  startContinuousAnalysis(callback: (result: TunerResult | null) => void): void {\n    console.log('[TunerAdapter] Запуск непрерывного анализа');\n    // Останавливаем предыдущий анализ, если он был запущен\n    if (this.stopContinuousAnalysis) {\n      this.stopContinuousAnalysis();\n    }\n\n    // Проверяем, есть ли анализатор\n    if (!this.audioDataAdapter['analyser']) {\n      console.error('[TunerAdapter] ОШИБКА: AnalyserNode не инициализирован!');\n    }\n\n    // Запускаем непрерывный анализ через TunerCore\n    this.stopContinuousAnalysis = this.tunerCore.startContinuousAnalysis(\n      this.audioDataAdapter,\n      this.animationAdapter,\n      this.buffer,\n      (result) => {\n        // console.log('[TunerAdapter] Результат анализа:', result); // Слишком много логов\n        callback(result);\n      },\n      () => this.isRunning\n    );\n    console.log('[TunerAdapter] Анализ запущен');\n  }\n\n  // Метод оставлен для совместимости, но не выполняет функционал\n  startTunerServiceAnalysis(callback: (result: TunerResult | null) => void): void {\n    console.warn('startTunerServiceAnalysis не поддерживается без прямой зависимости от TunerService');\n  }\n\n  // Дополнительные методы для доступа к TunerCore\n  getTunerCore(): TunerCore {\n    return this.tunerCore;\n  }\n\n  // Метод для получения состояния\n  isAudioRunning(): boolean {\n    return this.isRunning;\n  }\n\n  // Метод для переключения между режимами анализа\n  useTunerCoreAnalysis(useCore: boolean): void {\n    // Здесь можно реализовать переключение между использованием\n    // TunerCore и TunerService для анализа\n    if (useCore) {\n      console.log('Using TunerCore for analysis');\n    } else {\n      console.log('Using TunerService for analysis');\n    }\n  }\n}\n\n// Экспортируем экземпляр адаптера\nexport const tunerAdapter = new TunerAdapter();"],"names":[],"mappings":"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"}},
    {"offset": {"line": 509, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/features/tuner/services/TunerService.ts"],"sourcesContent":["import { TunerResult } from '../../../domain/entities';\nimport { tunerAdapter } from '../../../core/adapters/TunerAdapter';\n\ndeclare global {\n  interface Window {\n    webkitAudioContext: typeof AudioContext;\n  }\n}\n\nexport class TunerService {\n  private isRunning: boolean = false;\n\n  async start(): Promise<void> {\n    console.log('[TunerService] Запуск тюнера');\n    await tunerAdapter.start();\n    this.isRunning = true;\n  }\n\n  stop(): void {\n    console.log('[TunerService] Остановка тюнера');\n    tunerAdapter.stop();\n    this.isRunning = false;\n  }\n\n  async getPitch(): Promise<TunerResult | null> {\n    return tunerAdapter.getPitch();\n  }\n\n  startContinuousAnalysis(callback: (result: TunerResult | null) => void): void {\n    console.log('[TunerService] Запуск непрерывного анализа');\n    tunerAdapter.startContinuousAnalysis(callback);\n  }\n\n  // Методы для прямого использования TunerCore\n  analyzeFrequency(frequency: number): TunerResult {\n    return tunerAdapter.analyzeFrequency(frequency);\n  }\n\n  analyzeFrequencyForGuitar(frequency: number): TunerResult {\n    return tunerAdapter.analyzeFrequencyForGuitar(frequency);\n  }\n\n  getClosestGuitarNote(pitch: number) {\n    return tunerAdapter.getClosestGuitarNote(pitch);\n  }\n\n  getGuitarNotes() {\n    return tunerAdapter.getGuitarNotes();\n  }\n\n  frequencyFromNoteNumber(note: number): number {\n    return tunerAdapter.frequencyFromNoteNumber(note);\n  }\n\n  autoCorrelate(buf: Float32Array, sampleRate: number): number {\n    return tunerAdapter.autoCorrelate(buf, sampleRate);\n  }\n\n  isAudioRunning(): boolean {\n    return this.isRunning;\n  }\n\n  // Метод для переключения между режимами анализа\n  useTunerCoreAnalysis(useCore: boolean): void {\n    tunerAdapter.useTunerCoreAnalysis(useCore);\n  }\n\n  // Метод для прямого использования TunerService\n  startTunerServiceAnalysis(callback: (result: TunerResult | null) => void): void {\n    tunerAdapter.startTunerServiceAnalysis(callback);\n  }\n}\n\nexport const tunerService = new TunerService();"],"names":[],"mappings":";;;;;;AACA;;AAQO,MAAM;IACH,YAAqB,MAAM;IAEnC,MAAM,QAAuB;QAC3B,QAAQ,GAAG,CAAC;QACZ,MAAM,uJAAY,CAAC,KAAK;QACxB,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,OAAa;QACX,QAAQ,GAAG,CAAC;QACZ,uJAAY,CAAC,IAAI;QACjB,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,MAAM,WAAwC;QAC5C,OAAO,uJAAY,CAAC,QAAQ;IAC9B;IAEA,wBAAwB,QAA8C,EAAQ;QAC5E,QAAQ,GAAG,CAAC;QACZ,uJAAY,CAAC,uBAAuB,CAAC;IACvC;IAEA,6CAA6C;IAC7C,iBAAiB,SAAiB,EAAe;QAC/C,OAAO,uJAAY,CAAC,gBAAgB,CAAC;IACvC;IAEA,0BAA0B,SAAiB,EAAe;QACxD,OAAO,uJAAY,CAAC,yBAAyB,CAAC;IAChD;IAEA,qBAAqB,KAAa,EAAE;QAClC,OAAO,uJAAY,CAAC,oBAAoB,CAAC;IAC3C;IAEA,iBAAiB;QACf,OAAO,uJAAY,CAAC,cAAc;IACpC;IAEA,wBAAwB,IAAY,EAAU;QAC5C,OAAO,uJAAY,CAAC,uBAAuB,CAAC;IAC9C;IAEA,cAAc,GAAiB,EAAE,UAAkB,EAAU;QAC3D,OAAO,uJAAY,CAAC,aAAa,CAAC,KAAK;IACzC;IAEA,iBAA0B;QACxB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA,gDAAgD;IAChD,qBAAqB,OAAgB,EAAQ;QAC3C,uJAAY,CAAC,oBAAoB,CAAC;IACpC;IAEA,+CAA+C;IAC/C,0BAA0B,QAA8C,EAAQ;QAC9E,uJAAY,CAAC,yBAAyB,CAAC;IACzC;AACF;AAEO,MAAM,eAAe,IAAI"}},
    {"offset": {"line": 572, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/features/tuner/components/TunerDisplay.tsx"],"sourcesContent":["import React from 'react';\n\ninterface TunerDisplayProps {\n  currentNote: string;\n  currentFrequency: number;\n  currentDetune: number;\n  pointerPosition: number;\n  isInTune: boolean;\n}\n\nexport const TunerDisplay: React.FC<TunerDisplayProps> = ({\n  currentNote,\n  currentFrequency,\n  currentDetune,\n  pointerPosition,\n  isInTune\n}) => {\n  return (\n    <div className=\"flex flex-col items-center\">\n      {/* Нота */}\n      <div className={`text-6xl font-bold mb-2 transition-colors ${\n        isInTune ? 'text-green-400' : 'text-white'\n      }`}>\n        {currentNote}\n      </div>\n\n      {/* Частота */}\n      <div className=\"text-slate-400 mb-4\">\n        <span className=\"text-xl\">{currentFrequency}</span> Hz\n      </div>\n\n      {/* Индикатор настройки */}\n      <div className=\"w-full h-5 bg-slate-700 rounded-full relative mb-2 overflow-hidden\">\n        <div \n          className={`absolute top-0 w-1 h-full transition-all duration-100 ${\n            isInTune ? 'bg-green-400 shadow-lg shadow-green-400/50' : 'bg-white'\n          }`}\n          style={{ \n            left: `${pointerPosition}%`,\n            transform: 'translateX(-50%)'\n          }}\n        />\n      </div>\n\n      {/* Шкала */}\n      <div className=\"flex justify-between w-full px-2 mb-2\">\n        <span className=\"text-xs text-slate-500\">-50</span>\n        <span className=\"text-xs text-slate-500\">0</span>\n        <span className=\"text-xs text-slate-500\">+50</span>\n      </div>\n\n      {/* Центы */}\n      <div className=\"text-slate-400 text-sm\">\n        {currentDetune} cents\n      </div>\n    </div>\n  );\n};"],"names":[],"mappings":";;;;;;AAUO,MAAM,eAA4C,CAAC,EACxD,WAAW,EACX,gBAAgB,EAChB,aAAa,EACb,eAAe,EACf,QAAQ,EACT;IACC,qBACE,8OAAC;QAAI,WAAU;;0BAEb,8OAAC;gBAAI,WAAW,CAAC,0CAA0C,EACzD,WAAW,mBAAmB,cAC9B;0BACC;;;;;;0BAIH,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAK,WAAU;kCAAW;;;;;;oBAAwB;;;;;;;0BAIrD,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC;oBACC,WAAW,CAAC,sDAAsD,EAChE,WAAW,+CAA+C,YAC1D;oBACF,OAAO;wBACL,MAAM,GAAG,gBAAgB,CAAC,CAAC;wBAC3B,WAAW;oBACb;;;;;;;;;;;0BAKJ,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAK,WAAU;kCAAyB;;;;;;kCACzC,8OAAC;wBAAK,WAAU;kCAAyB;;;;;;kCACzC,8OAAC;wBAAK,WAAU;kCAAyB;;;;;;;;;;;;0BAI3C,8OAAC;gBAAI,WAAU;;oBACZ;oBAAc;;;;;;;;;;;;;AAIvB"}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/features/tuner/components/TunerControls.tsx"],"sourcesContent":["import React from 'react';\nimport { TunerMode } from '../../../store/slices/tunerSlice';\n\ninterface TunerControlsProps {\n  isRunning: boolean;\n  mode: TunerMode;\n  onToggle: () => void;\n  onModeChange: (mode: TunerMode) => void;\n}\n\nexport const TunerControls: React.FC<TunerControlsProps> = ({\n  isRunning,\n  mode,\n  onToggle,\n  onModeChange\n}) => {\n  return (\n    <div className=\"mb-6\">\n      <button\n        onClick={onToggle}\n        className={`w-full py-3 px-4 rounded-lg font-medium transition-colors ${\n          isRunning \n            ? 'bg-red-600 hover:bg-red-700 text-white' \n            : 'bg-blue-600 hover:bg-blue-700 text-white'\n        }`}\n      >\n        {isRunning ? 'Выключить микрофон' : 'Включить микрофон'}\n      </button>\n\n      {/* Переключатель режима */}\n      <div className=\"flex justify-center gap-6 mt-4\">\n        <label className=\"flex items-center cursor-pointer\">\n          <input\n            type=\"radio\"\n            name=\"mode\"\n            value=\"chromatic\"\n            checked={mode === 'chromatic'}\n            onChange={(e) => onModeChange(e.target.value as TunerMode)}\n            className=\"mr-2 text-blue-600 focus:ring-blue-500\"\n          />\n          <span className=\"text-slate-300\">Хроматический</span>\n        </label>\n        <label className=\"flex items-center cursor-pointer\">\n          <input\n            type=\"radio\"\n            name=\"mode\"\n            value=\"guitar\"\n            checked={mode === 'guitar'}\n            onChange={(e) => onModeChange(e.target.value as TunerMode)}\n            className=\"mr-2 text-blue-600 focus:ring-blue-500\"\n          />\n          <span className=\"text-slate-300\">Гитара (EADGBE)</span>\n        </label>\n      </div>\n    </div>\n  );\n};"],"names":[],"mappings":";;;;;;AAUO,MAAM,gBAA8C,CAAC,EAC1D,SAAS,EACT,IAAI,EACJ,QAAQ,EACR,YAAY,EACb;IACC,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBACC,SAAS;gBACT,WAAW,CAAC,0DAA0D,EACpE,YACI,2CACA,4CACJ;0BAED,YAAY,uBAAuB;;;;;;0BAItC,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAM,WAAU;;0CACf,8OAAC;gCACC,MAAK;gCACL,MAAK;gCACL,OAAM;gCACN,SAAS,SAAS;gCAClB,UAAU,CAAC,IAAM,aAAa,EAAE,MAAM,CAAC,KAAK;gCAC5C,WAAU;;;;;;0CAEZ,8OAAC;gCAAK,WAAU;0CAAiB;;;;;;;;;;;;kCAEnC,8OAAC;wBAAM,WAAU;;0CACf,8OAAC;gCACC,MAAK;gCACL,MAAK;gCACL,OAAM;gCACN,SAAS,SAAS;gCAClB,UAAU,CAAC,IAAM,aAAa,EAAE,MAAM,CAAC,KAAK;gCAC5C,WAAU;;;;;;0CAEZ,8OAAC;gCAAK,WAAU;0CAAiB;;;;;;;;;;;;;;;;;;;;;;;;AAK3C"}},
    {"offset": {"line": 778, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmitrij/Desktop/strummaster/src/app/tuner/TunerClient.tsx"],"sourcesContent":["'use client';\n\nimport React, { useEffect } from 'react';\nimport { useAppSelector, useAppDispatch } from '../../store/hooks';\nimport { \n  startTuner, \n  stopTuner, \n  updateTunerResult,\n  setTunerError,\n  setTunerMode,\n  TunerMode\n} from '../../store/slices/tunerSlice';\nimport { tunerService } from '../../features/tuner/services/TunerService';\nimport { TunerDisplay } from '../../features/tuner/components/TunerDisplay';\nimport { TunerControls } from '../../features/tuner/components/TunerControls';\n\nexport default function TunerPage() {\n  const dispatch = useAppDispatch();\n  const { isRunning, mode, error, currentNote, currentFrequency, currentDetune, pointerPosition, isInTune } = useAppSelector(state => state.tuner);\n\n  useEffect(() => {\n    // Cleanup on unmount\n    return () => {\n      if (isRunning) {\n        stopTunerService();\n      }\n    };\n  }, [isRunning]);\n\n  const startTunerService = async () => {\n    try {\n      await tunerService.start();\n      dispatch(startTuner());\n      \n      tunerService.startContinuousAnalysis((result) => {\n        if (result) {\n          dispatch(updateTunerResult(result));\n        }\n      });\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to start tuner';\n      dispatch(setTunerError(errorMessage));\n    }\n  };\n\n  const stopTunerService = () => {\n    tunerService.stop();\n    dispatch(stopTuner());\n  };\n\n  const handleModeChange = (newMode: TunerMode) => {\n    dispatch(setTunerMode(newMode));\n  };\n\n  return (\n    <div className=\"min-h-screen bg-slate-900 flex items-center justify-center p-4\">\n      <div className=\"bg-slate-800/95 border border-white/10 rounded-2xl shadow-2xl w-full max-w-md p-6\">\n        <h1 className=\"text-2xl font-bold text-white mb-6 text-center\">Guitar Tuner</h1>\n\n        {error && (\n          <div className=\"bg-red-900/20 border border-red-500/30 text-red-400 p-3 rounded-lg mb-4 text-sm\">\n            {error}\n          </div>\n        )}\n\n        <TunerControls \n          isRunning={isRunning}\n          mode={mode}\n          onToggle={isRunning ? stopTunerService : startTunerService}\n          onModeChange={handleModeChange}\n        />\n\n        <TunerDisplay\n          currentNote={currentNote}\n          currentFrequency={currentFrequency}\n          currentDetune={currentDetune}\n          pointerPosition={pointerPosition}\n          isInTune={isInTune}\n        />\n      </div>\n    </div>\n  );\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAQA;AACA;AACA;AAdA;;;;;;;;AAgBe,SAAS;IACtB,MAAM,WAAW,IAAA,uIAAc;IAC/B,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,WAAW,EAAE,gBAAgB,EAAE,aAAa,EAAE,eAAe,EAAE,QAAQ,EAAE,GAAG,IAAA,uIAAc,EAAC,CAAA,QAAS,MAAM,KAAK;IAE/I,IAAA,kNAAS,EAAC;QACR,qBAAqB;QACrB,OAAO;YACL,IAAI,WAAW;gBACb;YACF;QACF;IACF,GAAG;QAAC;KAAU;IAEd,MAAM,oBAAoB;QACxB,IAAI;YACF,MAAM,oKAAY,CAAC,KAAK;YACxB,SAAS,IAAA,kJAAU;YAEnB,oKAAY,CAAC,uBAAuB,CAAC,CAAC;gBACpC,IAAI,QAAQ;oBACV,SAAS,IAAA,yJAAiB,EAAC;gBAC7B;YACF;QACF,EAAE,OAAO,KAAK;YACZ,MAAM,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;YAC1D,SAAS,IAAA,qJAAa,EAAC;QACzB;IACF;IAEA,MAAM,mBAAmB;QACvB,oKAAY,CAAC,IAAI;QACjB,SAAS,IAAA,iJAAS;IACpB;IAEA,MAAM,mBAAmB,CAAC;QACxB,SAAS,IAAA,oJAAY,EAAC;IACxB;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;;8BACb,8OAAC;oBAAG,WAAU;8BAAiD;;;;;;gBAE9D,uBACC,8OAAC;oBAAI,WAAU;8BACZ;;;;;;8BAIL,8OAAC,yKAAa;oBACZ,WAAW;oBACX,MAAM;oBACN,UAAU,YAAY,mBAAmB;oBACzC,cAAc;;;;;;8BAGhB,8OAAC,uKAAY;oBACX,aAAa;oBACb,kBAAkB;oBAClB,eAAe;oBACf,iBAAiB;oBACjB,UAAU;;;;;;;;;;;;;;;;;AAKpB"}}]
}